/* yocto-mongoose - Utility tool to manage mongoose connection and auto loading models. - V2.2.0 */

"use strict";var logger=require("yocto-logger"),_=require("lodash"),Q=require("q"),Schema=require("mongoose").Schema,modCrypt=require("../crypto");function Crud(e){this.logger=e,this.alias={create:["insert"],get:["read"],getOne:["readOne"],delete:["destroy"],update:["modify"]},this.crypt=modCrypt(e)}Crud.prototype.insert=function(){return this.create.apply(this,arguments)},Crud.prototype.read=function(){return this.get.apply(this,arguments)},Crud.prototype.readOne=function(){return this.getOne.apply(this,arguments)},Crud.prototype.modify=function(){return this.update.apply(this,arguments)},Crud.prototype.destroy=function(){return this.delete.apply(this,arguments)},Crud.prototype.getOne=function(e,t){return this.get(e,t,"findOne")},Crud.prototype.get=function(t,i,r){var n=this["findOne"===r?"getOneRedis":"getRedis"];r=_.isString(r)&&!_.isEmpty(r)?r:"find",r=_.isString(t)?"findById":r;var s=Q.defer();i=_.isString(i)&&!_.isEmpty(i)?i:"";var o=this;function a(e,t,i){_.isPlainObject(e)&&(e=o.crypto().prepareCryptQuery(e,o.getProperties())),o[r](e,t,function(e,t){e?s.reject(e):(_.isObject(i)&&n.instance.add(i.key,t,i.expire),s.resolve(t))})}if(n){var c=_.merge(_.isString(t)?_.set([this.modelName,t].join("-"),t):t||{},i||{});n.instance.get(c).then(function(e){s.resolve(e)}).catch(function(e){a.call(this,t,i,_.isNull(e)?{key:c,expire:n.expire}:e)}.bind(this))}else a.call(this,t,i);return s.promise},Crud.prototype.delete=function(e){var i=Q.defer();return _.isString(e)&&!_.isEmpty(e)?this.findByIdAndRemove(e,function(e,t){e?i.reject(e):i.resolve(t)}):i.reject(["Given id is not a string",_.isString(e)&&_.isEmpty(e)?" and is empty":""].join(" ")),i.promise},Crud.prototype.update=function(e,t,i){var r=_.isString(e)?"findByIdAndUpdate":"findOneAndUpdate";_.isPlainObject(t)&&(t=this.crypto().prepareCryptQuery(t,this.getProperties()));var n=Q.defer();return _.isBoolean(i)&&i?this.where().setOptions({multi:!0}).update(e,t,function(e,t){e?n.reject(e):n.resolve(t)}):this[r](e,t,{new:!0},function(e,t){e?n.reject(e):n.resolve(t)}),n.promise},Crud.prototype.create=function(e){var i=Q.defer(),r=_.isFunction(this.save)?this:new this,t=!0,n=[];return _.isFunction(this.validate)&&(n=(t=this.validate(e)).error,e=_.has(t,"value")?t.value:e,t=_.isNull(t.error)),t?r instanceof this?(_.extend(r,e),r.save(function(e,t){e?i.reject(e):this.schema.elastic?r.on("es-indexed",function(e){e?i.reject(["[ Crud.create ] - Indexes creation failed :",e].join(" ")):i.resolve(t)}):i.resolve(t)}.bind(this))):i.reject("[ Crud.create ] - Cannot save. invalid instance model"):i.reject(["[ Crud.create ] - Cannot save new schema.",n].join(" ")),i.promise},Crud.prototype.esearch=function(e,t){var i=Q.defer();return!_.isUndefined(this.search)&&_.isFunction(this.search)?this.search(e||{},t||{},function(e,t){e?i.reject(e):i.resolve(t)}):i.reject("Elastic search is not enabled. Cannot process a search request"),i.promise},Crud.prototype.add=function(t,i,r,n){if(!_.isObject(t)&&!(t instanceof Schema)||!_.isArray(i))return this.logger.warning("[ Crud.add ] - Schema or exclude item given is invalid"),!1;var e=["add"];t.elastic||e.push("elasticsearch");var s=_.difference(Object.keys(Crud.prototype),e);if(i=_.isArray(i)?i:[],!_.isEmpty(i)&&_.isArray(i)){var o=_.intersection(Object.keys(this.alias),i);_.each(o,function(e){i.push(this.alias[e])}.bind(this)),i=_.flatten(i)}var a=_.difference(s,i);return _.each(a,function(e){_.isFunction(this[e])&&(r&&_.includes(r.value||[],e)&&t.static([e,"Redis"].join(""),{instance:n,expire:r.expire||0}),t.static(e,this[e]))}.bind(this)),t},module.exports=function(e){return(_.isUndefined(e)||_.isNull(e))&&(logger.warning("[ Crud.constructor ] - Invalid logger given. Use internal logger"),e=logger),new Crud(e)};