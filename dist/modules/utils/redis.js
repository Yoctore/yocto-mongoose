/* yocto-mongoose - Utility tool to manage mongoose connection and auto loading models. - V2.3.0 - Wed Jun 12 2019 18:35:41 GMT+0400 (+04)*/

"use strict";var logger=require("yocto-logger"),_=require("lodash"),utils=require("yocto-utils"),Redis=require("ioredis"),joi=require("joi"),Q=require("q"),fs=require("fs");function RedisUtils(e){this.logger=e,this.hosts=[{host:"127.0.0.1",port:6379}],this.options={retry:2e3,enableReadyCheck:!0},this.isReady=!1,this.cluster=null,this.defaultExpireTime=0}RedisUtils.prototype.getHosts=function(){return this.hosts},RedisUtils.prototype.getOptions=function(){return this.options},RedisUtils.prototype.disconnect=function(){return!_.isNull(this.cluster)&&this.cluster.disconnect()},RedisUtils.prototype.connect=function(e,t,i,s){var o=joi.array().required().items(joi.object().keys({host:joi.string().required().empty().default("127.0.0.1"),family:joi.number().optional().valid([4,6]),password:joi.string().optional().empty().min(32),db:joi.number().optional(),port:joi.number().required().default(6380),tls:joi.object().optional().keys({ca:joi.string().optional().empty(),key:joi.string().optional().empty(),cert:joi.string().optional().empty()})}).default({host:"127.0.0.1",port:6380})).default([{host:"127.0.0.1",port:6380}]),n=joi.validate(e,o);if(n.error)return this.logger.warning(["[ RedisUtils.connect ] - Invalid host config given :",n.error].join(" ")),!1;if(_.isNumber(i)&&0<i&&(this.defaultExpireTime=i),this.hosts=n.value,this.options=_.merge(this.options,t||{}),_.has(this.options,"retry")&&_.isNumber(this.options.retry)&&_.extend(this.options,{clusterRetryStrategy:function(){return this.options.retry}.bind(this)}),_.has(this.hosts,"tls.ca")&&(this.hosts.tls.ca=[fs.readFileSync(this.hosts.tls.ca)]),_.has(this.hosts,"tls.key")&&(this.hosts.tls.key=fs.readFileSync(this.hosts.tls.key)),_.has(this.hosts,"tls.cert")&&(this.hosts.tls.cert=fs.readFileSync(this.hosts.tls.cert)),_.isBoolean(s)&&s)this.logger.info("[ RedisUtils.connect ] - Try to connect in a cluster mode"),this.cluster=new Redis.Cluster(this.hosts,this.options);else{var r=_.first(n.value);this.logger.info("[ RedisUtils.connect ] - Try to connect in classic mode"),1<_.size(n.value)&&this.logger.warning(["[ RedisUtils.connect ] - Redis is not starting on cluster mode","connections parameters used will be the first item of current config."].join(" ")),this.cluster=new Redis(r)}return this.listenEvents()},RedisUtils.prototype.normalizeKey=function(e){return _.snakeCase(_.deburr(JSON.stringify(e))).toLowerCase()},RedisUtils.prototype.set=function(e,t,i){return this.add(e,t,i)},RedisUtils.prototype.add=function(e,t,i){return i=_.isNumber(i)&&0<i?i:this.defaultExpireTime,!_.isUndefined(this.crypto)&&_.isFunction(this.crypto)&&(t=this.crypto().redisPlainEncryptDecrypt(t,!0)),e=this.normalizeKey(e),this.isReady&&(0<i?(this.logger.debug(["[ RedisUtils.add ] - Adding key [",e,"] with [",i,"] seconds of expires times,","with value :",utils.obj.inspect(t)].join(" ")),this.cluster.set(e,JSON.stringify(t),"EX",i)):(this.logger.debug(["[ RedisUtils.add ] - Adding key [",e,"] with value :",utils.obj.inspect(t)].join(" ")),this.cluster.set(e,JSON.stringify(t)))),this.get(e)},RedisUtils.prototype.remove=function(){var e=Q.defer(),t=_.flatten(_.map(arguments));if(this.isReady){var i=this.cluster.pipeline();t.forEach(function(e){i.del(this.normalizeKey(e))}.bind(this)),i.exec().then(function(){this.logger.debug(["[ RedisUtils.remove ] - Remove keys",utils.obj.inspect(t),"was processed"].join(" ")),e.resolve()}.bind(this))}else this.logger.warning(["[ RedisUtils.remove ] - keys [",t,"] was not removed because connection is down"].join(" "));return e.promise},RedisUtils.prototype.flush=function(e){var t=Q.defer();e=_.isString(e)&&!_.isEmpty(e)?e:"*";var i=0,s=this.cluster.scanStream({match:e});return this.logger.debug("[ RedisUtils.flush ] - flush was starting."),s.on("data",function(e){i+=_.size(e),0<_.size(e)&&this.remove(e)}.bind(this)),s.on("end",function(){0===i&&this.logger.debug(["[ RedisUtils.flush ] - No keys found for given pattern [",e,"*"===e?"(Default) ]":"]"].join(" ")),this.logger.debug(["[ RedisUtils.flush ] - flush was ending.",i,"keys was removed"].join(" ")),t.resolve()}.bind(this)),t.promise},RedisUtils.prototype.delete=function(){return this.remove(_.flatten(_.map(arguments)))},RedisUtils.prototype.get=function(i){var s=Q.defer();return this.isReady?this.cluster.get(this.normalizeKey(i),function(e,t){e?(this.logger.error(["[ RedisUtils.get ] - Cannot get value for key [",this.normalizeKey(i),"] on redis :",e].join(" ")),s.reject(e)):_.isNull(t)?s.reject(i):(!_.isUndefined(this.crypto)&&_.isFunction(this.crypto)&&(t=this.crypto().redisPlainEncryptDecrypt(JSON.parse(t),!1)),s.resolve(t))}.bind(this)):s.reject("Redis is not ready cannot process get action"),s.promise},RedisUtils.prototype.listenEvents=function(){return _.each([{key:"connect",message:"is connecting"},{key:"ready",message:"is ready"},{key:"error",message:"errored"},{key:"close",message:"is closing"},{key:"reconnecting",message:"is reconnecting"},{key:"end",message:"is ending"},{key:"+node",message:"connecting to a new node"},{key:"-node",message:"disconnecting from a node"},{key:"node error",message:"is on error on a node"}],function(t){this.cluster.on(t.key,function(e){"ready"===t.key&&(this.isReady=!0),_.includes(["error","close","reconnecting","end","node error"],t.key)&&(this.isReady=!1),this.logger["ready"!==t.key?"debug":"info"](["[ RedisUtils.listenEvents ] â€“ Redis",t.message,e?["=>",e].join(" "):""].join(" "))}.bind(this))}.bind(this)),!0},module.exports=function(e){return(_.isUndefined(e)||_.isNull(e))&&(logger.warning("[ RedisUtils.constructor ] - Invalid logger given. Use internal logger"),e=logger),new RedisUtils(e)};